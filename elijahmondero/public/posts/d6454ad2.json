{
  "id": "d6454ad2",
  "title": ".NET 9 Networking Improvements",
  "excerpt": "An overview of the latest and most interesting changes in the networking space with the new .NET 9 release, including HTTP performance improvements, support for multiple HTTP/3 connections, and auto-updating Windows proxy.",
  "fullPost": "Continuing our tradition, we are excited to share a blog post highlighting the latest and most interesting changes in the networking space with the new .NET 9 release. This year, we are introducing updates in the HTTP space, new HttpClientFactory APIs, .NET Framework compatibility improvements, and more.\n\nHTTP\nIn this release, we made two impactful performance improvements in HTTP connection pooling. We added opt-in support for multiple HTTP/3 connections. Using more than one HTTP/3 connection to the peer is discouraged by the RFC 9114 since the connection can multiplex parallel requests. However, in certain scenarios, like server-to-server, one connection might become a bottleneck even with request multiplexing. We saw such limitations with HTTP/2, which has the same concept of multiplexing over one connection. For the same reasons, we decided to implement multiple connection support for HTTP/3. The implementation itself tries to closely match the behavior of HTTP/2 multiple connections, preferring to saturate existing connections with as many requests as allowed by the peer before opening a new one. Note that this is an implementation detail and the behavior might change in the future.\n\nOur benchmarks showed a nontrivial increase in requests per seconds (RPS), comparison for 10,000 parallel requests:\n\nclient | single HTTP/3 connection | multiple HTTP/3 connections\n--- | --- | ---\nMax CPU Usage (%) | 35 | 92\nMax Cores Usage (%) | 971 | 2,572\nMax Working Set (MB) | 3,810 | 6,491\nMax Private Memory (MB) | 4,415 | 7,228\nProcessor Count | 28 | 28\nFirst request duration (ms) | 519 | 594\nRequests | 345,446 | 4,325,325\nMean RPS | 23,069 | 288,664\n\nThe increase in Max CPU Usage implies better CPU utilization, which means that the CPU is busy processing requests instead of being idle. This feature can be turned on via the EnableMultipleHttp3Connections property on SocketsHttpHandler:\n\n```csharp\nvar client = new HttpClient(new SocketsHttpHandler\n{\n    EnableMultipleHttp3Connections = true\n});\n```\n\nWe also addressed lock contention in HTTP 1.1 connection pooling. The HTTP 1.1 connection pool previously used a single lock to manage the list of connections and the queue of pending requests. This lock was observed to be a bottleneck in high throughput scenarios on machines with a high number of CPU cores. We resolved this problem by replacing an ordinary list with a lock with a concurrent collection. We chose ConcurrentStack as it preserves the observable behavior when requests are handled by the newest available connection, which allows collecting older connections when their configured lifetime expires. The throughput of HTTP 1.1 requests in our benchmarks increased by more than 30%:\n\nClient | .NET 8.0 | .NET 9.0 | Increase\n--- | --- | --- | ---\nRequests | 80,028,791 | 107,128,778 | +33.86%\nMean RPS | 666,886 | 892,749 | +33.87%\n\nProxy Auto Update on Windows\nOne of the main pain points when debugging HTTP traffic of applications using earlier versions of .NET is that the application doesn\u2019t react to changes in Windows proxy settings. The proxy settings were previously initialized once per process with no reasonable ability to refresh the settings.",
  "datePosted": "2025-02-19T10:24:54.971913Z",
  "postedBy": "Elijah Mondero",
  "tags": [
    ".NET 9",
    "Networking",
    "HTTP",
    "Performance",
    "HttpClientFactory",
    "Windows Proxy"
  ],
  "sources": [],
  "image_path": "elijahmondero/public/posts/images/6d55e6a3-212f-4e76-a853-8d33c69a15e4.png"
}